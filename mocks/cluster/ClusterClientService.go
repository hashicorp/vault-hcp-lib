// Code generated by mockery v2.34.2. DO NOT EDIT.

package clustermocks

import (
	runtime "github.com/go-openapi/runtime"
	mock "github.com/stretchr/testify/mock"

	vault_service "github.com/hashicorp/hcp-sdk-go/clients/cloud-vault-service/stable/2020-11-25/client/vault_service"
)

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

// AddPlugin provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AddPlugin(params *vault_service.AddPluginParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.AddPluginOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.AddPluginOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.AddPluginParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.AddPluginOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.AddPluginParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.AddPluginOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.AddPluginOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.AddPluginParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) Create(params *vault_service.CreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.CreateOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.CreateOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.CreateParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.CreateOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.CreateParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.CreateOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.CreateOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.CreateParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSnapshot provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CreateSnapshot(params *vault_service.CreateSnapshotParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.CreateSnapshotOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.CreateSnapshotOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.CreateSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.CreateSnapshotOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.CreateSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.CreateSnapshotOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.CreateSnapshotOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.CreateSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) Delete(params *vault_service.DeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.DeleteOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.DeleteOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.DeleteParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.DeleteOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.DeleteParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.DeleteOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.DeleteOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.DeleteParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePathsFilter provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeletePathsFilter(params *vault_service.DeletePathsFilterParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.DeletePathsFilterOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.DeletePathsFilterOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.DeletePathsFilterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.DeletePathsFilterOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.DeletePathsFilterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.DeletePathsFilterOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.DeletePathsFilterOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.DeletePathsFilterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePlugin provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeletePlugin(params *vault_service.DeletePluginParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.DeletePluginOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.DeletePluginOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.DeletePluginParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.DeletePluginOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.DeletePluginParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.DeletePluginOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.DeletePluginOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.DeletePluginParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSentinelPolicy provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeleteSentinelPolicy(params *vault_service.DeleteSentinelPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.DeleteSentinelPolicyOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.DeleteSentinelPolicyOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.DeleteSentinelPolicyParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.DeleteSentinelPolicyOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.DeleteSentinelPolicyParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.DeleteSentinelPolicyOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.DeleteSentinelPolicyOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.DeleteSentinelPolicyParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSnapshot provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeleteSnapshot(params *vault_service.DeleteSnapshotParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.DeleteSnapshotOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.DeleteSnapshotOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.DeleteSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.DeleteSnapshotOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.DeleteSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.DeleteSnapshotOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.DeleteSnapshotOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.DeleteSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeregisterLinkedCluster provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeregisterLinkedCluster(params *vault_service.DeregisterLinkedClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.DeregisterLinkedClusterOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.DeregisterLinkedClusterOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.DeregisterLinkedClusterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.DeregisterLinkedClusterOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.DeregisterLinkedClusterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.DeregisterLinkedClusterOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.DeregisterLinkedClusterOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.DeregisterLinkedClusterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisableCORS provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DisableCORS(params *vault_service.DisableCORSParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.DisableCORSOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.DisableCORSOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.DisableCORSParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.DisableCORSOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.DisableCORSParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.DisableCORSOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.DisableCORSOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.DisableCORSParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FetchAuditLog provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FetchAuditLog(params *vault_service.FetchAuditLogParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.FetchAuditLogOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.FetchAuditLogOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.FetchAuditLogParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.FetchAuditLogOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.FetchAuditLogParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.FetchAuditLogOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.FetchAuditLogOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.FetchAuditLogParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) Get(params *vault_service.GetParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAdminToken provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetAdminToken(params *vault_service.GetAdminTokenParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetAdminTokenOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetAdminTokenOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetAdminTokenParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetAdminTokenOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetAdminTokenParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetAdminTokenOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetAdminTokenOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetAdminTokenParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAuditLogStatus provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetAuditLogStatus(params *vault_service.GetAuditLogStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetAuditLogStatusOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetAuditLogStatusOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetAuditLogStatusParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetAuditLogStatusOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetAuditLogStatusParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetAuditLogStatusOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetAuditLogStatusOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetAuditLogStatusParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAvailableProviders provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetAvailableProviders(params *vault_service.GetAvailableProvidersParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetAvailableProvidersOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetAvailableProvidersOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetAvailableProvidersParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetAvailableProvidersOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetAvailableProvidersParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetAvailableProvidersOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetAvailableProvidersOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetAvailableProvidersParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAvailableTemplates provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetAvailableTemplates(params *vault_service.GetAvailableTemplatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetAvailableTemplatesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetAvailableTemplatesOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetAvailableTemplatesParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetAvailableTemplatesOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetAvailableTemplatesParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetAvailableTemplatesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetAvailableTemplatesOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetAvailableTemplatesParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCORSConfig provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetCORSConfig(params *vault_service.GetCORSConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetCORSConfigOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetCORSConfigOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetCORSConfigParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetCORSConfigOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetCORSConfigParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetCORSConfigOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetCORSConfigOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetCORSConfigParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientCounts provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetClientCounts(params *vault_service.GetClientCountsParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetClientCountsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetClientCountsOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetClientCountsParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetClientCountsOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetClientCountsParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetClientCountsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetClientCountsOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetClientCountsParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCurrentMilestone provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetCurrentMilestone(params *vault_service.GetCurrentMilestoneParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetCurrentMilestoneOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetCurrentMilestoneOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetCurrentMilestoneParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetCurrentMilestoneOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetCurrentMilestoneParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetCurrentMilestoneOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetCurrentMilestoneOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetCurrentMilestoneParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLinkedCluster provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetLinkedCluster(params *vault_service.GetLinkedClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetLinkedClusterOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetLinkedClusterOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetLinkedClusterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetLinkedClusterOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetLinkedClusterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetLinkedClusterOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetLinkedClusterOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetLinkedClusterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReplicationStatus provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetReplicationStatus(params *vault_service.GetReplicationStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetReplicationStatusOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetReplicationStatusOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetReplicationStatusParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetReplicationStatusOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetReplicationStatusParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetReplicationStatusOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetReplicationStatusOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetReplicationStatusParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSnapshot provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetSnapshot(params *vault_service.GetSnapshotParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetSnapshotOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetSnapshotOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetSnapshotOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetSnapshotOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetSnapshotOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUtilization provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetUtilization(params *vault_service.GetUtilizationParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.GetUtilizationOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.GetUtilizationOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.GetUtilizationParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.GetUtilizationOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.GetUtilizationParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.GetUtilizationOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.GetUtilizationOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.GetUtilizationParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsVaultPluginRegistered provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IsVaultPluginRegistered(params *vault_service.IsVaultPluginRegisteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.IsVaultPluginRegisteredOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.IsVaultPluginRegisteredOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.IsVaultPluginRegisteredParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.IsVaultPluginRegisteredOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.IsVaultPluginRegisteredParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.IsVaultPluginRegisteredOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.IsVaultPluginRegisteredOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.IsVaultPluginRegisteredParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) List(params *vault_service.ListParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.ListOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.ListOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.ListParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.ListOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.ListParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.ListOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.ListOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.ListParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAllClusters provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListAllClusters(params *vault_service.ListAllClustersParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.ListAllClustersOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.ListAllClustersOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.ListAllClustersParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.ListAllClustersOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.ListAllClustersParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.ListAllClustersOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.ListAllClustersOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.ListAllClustersParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPerformanceReplicationSecondaries provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListPerformanceReplicationSecondaries(params *vault_service.ListPerformanceReplicationSecondariesParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.ListPerformanceReplicationSecondariesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.ListPerformanceReplicationSecondariesOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.ListPerformanceReplicationSecondariesParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.ListPerformanceReplicationSecondariesOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.ListPerformanceReplicationSecondariesParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.ListPerformanceReplicationSecondariesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.ListPerformanceReplicationSecondariesOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.ListPerformanceReplicationSecondariesParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSnapshots provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListSnapshots(params *vault_service.ListSnapshotsParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.ListSnapshotsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.ListSnapshotsOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.ListSnapshotsParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.ListSnapshotsOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.ListSnapshotsParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.ListSnapshotsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.ListSnapshotsOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.ListSnapshotsParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Lock provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) Lock(params *vault_service.LockParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.LockOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.LockOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.LockParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.LockOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.LockParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.LockOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.LockOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.LockParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PluginRegistrationStatus provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PluginRegistrationStatus(params *vault_service.PluginRegistrationStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.PluginRegistrationStatusOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.PluginRegistrationStatusOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.PluginRegistrationStatusParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.PluginRegistrationStatusOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.PluginRegistrationStatusParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.PluginRegistrationStatusOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.PluginRegistrationStatusOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.PluginRegistrationStatusParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RecreateFromSnapshot provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RecreateFromSnapshot(params *vault_service.RecreateFromSnapshotParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.RecreateFromSnapshotOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.RecreateFromSnapshotOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.RecreateFromSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.RecreateFromSnapshotOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.RecreateFromSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.RecreateFromSnapshotOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.RecreateFromSnapshotOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.RecreateFromSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterLinkedCluster provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RegisterLinkedCluster(params *vault_service.RegisterLinkedClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.RegisterLinkedClusterOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.RegisterLinkedClusterOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.RegisterLinkedClusterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.RegisterLinkedClusterOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.RegisterLinkedClusterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.RegisterLinkedClusterOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.RegisterLinkedClusterOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.RegisterLinkedClusterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreSnapshot provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RestoreSnapshot(params *vault_service.RestoreSnapshotParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.RestoreSnapshotOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.RestoreSnapshotOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.RestoreSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.RestoreSnapshotOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.RestoreSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.RestoreSnapshotOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.RestoreSnapshotOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.RestoreSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeAdminTokens provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RevokeAdminTokens(params *vault_service.RevokeAdminTokensParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.RevokeAdminTokensOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.RevokeAdminTokensOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.RevokeAdminTokensParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.RevokeAdminTokensOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.RevokeAdminTokensParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.RevokeAdminTokensOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.RevokeAdminTokensOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.RevokeAdminTokensParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Seal provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) Seal(params *vault_service.SealParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.SealOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.SealOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.SealParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.SealOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.SealParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.SealOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.SealOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.SealParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTransport provides a mock function with given fields: transport
func (_m *ClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// Unlock provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) Unlock(params *vault_service.UnlockParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.UnlockOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.UnlockOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.UnlockParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.UnlockOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.UnlockParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.UnlockOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.UnlockOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.UnlockParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Unseal provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) Unseal(params *vault_service.UnsealParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.UnsealOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.UnsealOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.UnsealParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.UnsealOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.UnsealParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.UnsealOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.UnsealOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.UnsealParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) Update(params *vault_service.UpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.UpdateOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.UpdateOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.UpdateParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.UpdateOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.UpdateParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.UpdateOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.UpdateOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.UpdateParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCORSConfig provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateCORSConfig(params *vault_service.UpdateCORSConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.UpdateCORSConfigOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.UpdateCORSConfigOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.UpdateCORSConfigParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.UpdateCORSConfigOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.UpdateCORSConfigParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.UpdateCORSConfigOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.UpdateCORSConfigOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.UpdateCORSConfigParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMajorVersionUpgradeConfig provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateMajorVersionUpgradeConfig(params *vault_service.UpdateMajorVersionUpgradeConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.UpdateMajorVersionUpgradeConfigOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.UpdateMajorVersionUpgradeConfigOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.UpdateMajorVersionUpgradeConfigParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.UpdateMajorVersionUpgradeConfigOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.UpdateMajorVersionUpgradeConfigParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.UpdateMajorVersionUpgradeConfigOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.UpdateMajorVersionUpgradeConfigOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.UpdateMajorVersionUpgradeConfigParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePathsFilter provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdatePathsFilter(params *vault_service.UpdatePathsFilterParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.UpdatePathsFilterOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.UpdatePathsFilterOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.UpdatePathsFilterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.UpdatePathsFilterOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.UpdatePathsFilterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.UpdatePathsFilterOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.UpdatePathsFilterOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.UpdatePathsFilterParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePublicIps provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdatePublicIps(params *vault_service.UpdatePublicIpsParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.UpdatePublicIpsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.UpdatePublicIpsOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.UpdatePublicIpsParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.UpdatePublicIpsOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.UpdatePublicIpsParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.UpdatePublicIpsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.UpdatePublicIpsOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.UpdatePublicIpsParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSnapshot provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateSnapshot(params *vault_service.UpdateSnapshotParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.UpdateSnapshotOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.UpdateSnapshotOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.UpdateSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.UpdateSnapshotOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.UpdateSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.UpdateSnapshotOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.UpdateSnapshotOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.UpdateSnapshotParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateVersion provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateVersion(params *vault_service.UpdateVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.UpdateVersionOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.UpdateVersionOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.UpdateVersionParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.UpdateVersionOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.UpdateVersionParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.UpdateVersionOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.UpdateVersionOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.UpdateVersionParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpgradeMajorVersion provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpgradeMajorVersion(params *vault_service.UpgradeMajorVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...vault_service.ClientOption) (*vault_service.UpgradeMajorVersionOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *vault_service.UpgradeMajorVersionOK
	var r1 error
	if rf, ok := ret.Get(0).(func(*vault_service.UpgradeMajorVersionParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) (*vault_service.UpgradeMajorVersionOK, error)); ok {
		return rf(params, authInfo, opts...)
	}
	if rf, ok := ret.Get(0).(func(*vault_service.UpgradeMajorVersionParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) *vault_service.UpgradeMajorVersionOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*vault_service.UpgradeMajorVersionOK)
		}
	}

	if rf, ok := ret.Get(1).(func(*vault_service.UpgradeMajorVersionParams, runtime.ClientAuthInfoWriter, ...vault_service.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewClientService creates a new instance of ClientService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientService {
	mock := &ClientService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
